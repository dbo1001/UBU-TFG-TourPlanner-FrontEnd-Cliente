\capitulo{3}{Conceptos teóricos}

En este apartado se describirán ciertos conceptos teóricos que resultan necesarios para la correcta comprensión del proyecto.

\section{Modelo Cliente-Servidor}

Una parte importante de este proyecto es el concepto del modelo cliente-servidor, ya que cumple con la estructura que se está utilizando. \cite{cs1} \cite{cs2}

Un esquema gráfico muy utilizado para definir este modelo es el siguiente:

\imagen{clienteServidor}{Definición gráfica del modelo cliente/servidor \cite{cs3}}

En este modelo y en el proyecto hay unas características principales y unos actores concretos que son los siguientes:

\subsection{Cliente}
\begin{itemize}
\item Este se encarga de lanzar solicitudes o peticiones al servidor. Cuando el cliente requiere cierta información, lanza una petición al servidor, quedando a la espera de recibir una respuesta. Normalmente en esta espera se encuentra definido un tiempo de espera máximo, para evitar desperdicio de recursos.

\item El cliente es capaz de lanzar peticiones a diferentes servidores, ya que pueden ser tipos de datos muy variados y sería impensable que un mismo origen de datos le ofreciera todo lo que necesite.

\item Este cliente contiene la interfaz que utilizará el usuario final, por lo que se consigue una interacción directa.
\end{itemize}

\subsection{Servidor}
\begin{itemize}
\item El servidor es la otra parte indispensable de este modelo, ya que en el momento en que esta iniciado se encarga de escuchar a la espera de peticiones del cliente.

\item Al igual que un cliente puede realizar distintas peticiones a distintos servidores, el servidor puede mantener conexión con un gran numero de clientes y procesar las peticiones. 

\end{itemize}

Al estar usando este modelo se consigue una serie de ventajas:
\begin{itemize}
\item \textbf{Centralización:} Al contar con un servidor que recibe todas las peticiones que le lance el cliente, se consigue un control de todos los accesos que se realizan y los recursos que se utilizan, pudiendo restringir o aumentar donde sea necesario.
\item Es un sistema muy fácilmente escalable, pudiendo aumentar las capacidades tanto de un lado como del otro independientemente, sin que al otro le afecte, o en todo caso teniendo que hacer modificaciones mínimas para que sea funcional. Esto mismo se traduce igualmente a la facilidad de mantenimiento, por las mismas razones.
\item Teniendo relación con la primera ventaja, se obtiene seguridad, ya que actualmente existen tecnologías que permiten conexiones seguras entre cliente y servidor, y a su vez evita posibles accesos fraudulentos que tengan intenciones no deseadas, ya que aunque varios clientes estén accediendo al mismo servidor, no pueden conocer las direcciones IP del resto. 
\end{itemize}

\section{Librería}

Cuando se habla de librerías \cite{lib1} \cite{lib2} podemos considerar varias opciones, pero a la que se refiere este caso es el hecho de desarrollar software de un tipo específico siguiendo ciertas reglas establecidas para así conseguir tener una cantidad indeterminada de programas y aplicaciones que contengan una estructura y una programación parecida, ya sea por el uso de los mismos métodos, o por seguir ciertos patrones con los que estructuras los programas de una manera concreta.

Este modelo estándar es algo que se consigue a través de la integración de librerías de código. Con ellas obtenemos métodos ya desarrollados para realizar determinados propósitos de programación. Al ser un origen de datos que siempre tendrá estos mismos métodos, se alcanza una estandarización a un gran nivel.

Al utilizar las librerías, también se obtiene un nivel de jerarquía que permite una organización más clara y sencilla. Una serie de clases que dependan de una librería acabarán teniendo varias similitudes, incluso compartirán código, lo cual servirá para agruparlas de mejor manera.

En el caso de Android, se puede considerar como estándar la librería que ofrecen para programar, ya que todas las aplicaciones que están desarrolladas por Google para este tipo de dispositivos mantienen una estructura bastante parecida en el desarrollo de ciertas técnicas.

Una forma visual de demostrar esto se encuentra en el menú que utilizan la mayoría de aplicaciones, como el de Google Maps, Gmail o la aplicación para visualizar imágenes. Todos estos ejemplos utilizan una estructura prácticamente idéntica, y con esto se consigue lo ya mencionado, estandarización, que será explicado en el apartado de técnicas y herramientas.

\section{Defectos de código}

Un \textit{Code Smell} o defecto de código \cite{refac2} se refiere a una serie de problemas que puede contener el código de un programa, que no causa un error a la hora de ejecutar o compilar el programa, pero es un problema de carácter mas profundo, que acarrea otra serie de fallos, como puede ser la lentitud en un programa.

Estos problemas también dificultan el mantenimiento del código a futuro, ya que puede ser un error que en la actualidad no cause fallos, pero en el momento que se realicen modificaciones un programa que contenga estos Code Smells será mas propenso a fallos críticos, que, dependiendo del tipo de Code Smell que lo haya provocado, puede ser mucho mas difícil detectarlo en ese momento que cuando se cometió.

Gracias a la identificación de los Code Smells, se puede saber cuándo es necesario refactorizar código, que es una técnica que se explicará mas adelante. Con respecto a la identificación también es importante mencionar que tiene un carácter muy subjetivo, dependiendo del programador o incluso del lenguaje de programación, aunque existen herramientas que son capaces de detectar bastantes tipos de defecto, ya que algunos son mas subjetivos que otros (en el caso de código duplicado, aunque también pueden existir falsos negativos).

\section{API}

Una API \cite{api1} o interfaz de programación de aplicaciones \cite{api2} se integra en otro software para que pueda hacer uso de rutinas, métodos y procedimientos con los cuales incluya su funcionalidad.

Visto de otra forma, se basa en el uso de bibliotecas, y con esto se consigue que el programador no tenga que desarrollar todo el código que se encuentra en ellas, ya que con hacer uso de sus métodos y llamadas ya consigue esas funcionalidades.

Por otro lado, al hacer esto también se consigue estandarización, debido a que todos los programas que usen esas librerías para implementar sus funcionalidades estarán haciendo los mismos procesos de llamadas y usando los mismos métodos, así que se benefician de todas las ventajas con las que cuenta la estandarización, pero a su vez también corremos el riesgo de que esa estandarización se rompa, bien porque la API deje de dar soporte a la biblioteca que estamos utilizando, o porque en las nuevas versiones de una aplicación ya no sea compatible nuestra API implementada. 

Podemos ver cómo se estructura la utilización de las APIs a través de este esquema:

\imagen{api1}{Esquema explicativo del uso de las APIs, fuente: \cite{api1}}


\section{Mantenimiento}

El concepto de mantenimiento en informática posee mucho valor, ya que el desarrollo de cualquier aplicación requiere mantenimiento posterior, y lo podemos dividir en dos aspectos:

\subsection{Soporte}

El soporte \cite{sup1} \cite{sup2} es una parte del mantenimiento, ya que después de cualquier desarrollo siempre habrá errores, \textit{bugs} o fallos, y éstos pueden ser problemas que no afecten al funcionamiento normal de un aplicación o por el contrario que causen su parada total, quedando inutilizable. 

El soporte es un servicio a través del cual un especialista informático brinda asistencia, de forma física o remota a un individuo o una organización que hacen uso de la herramienta. 

En el soporte remoto,se realiza a través de una aplicación web o un foro, donde además de personas especializadas en la aplicación, también hay otros usuarios que aportan su experiencia sobre ciertos problemas y en muchos casos estos problemas pueden ser resueltos sin necesidad de modificar el código, porque la falta de conocimiento del usuario es una de las mayores causas de incidencias que se suelen resolver en entornos de soporte.

\subsection{Actualización}

La otra parte importante del mantenimiento de una aplicación, sobre la que haremos mención en muchos aspectos de este trabajo es la actualización \cite{actu1}. 

Se basa en el cambio de código, APIs y librerías para obtener métodos nuevos, que están más optimizados para realizar la misma funcionalidad o también para solucionar errores que existieran en versiones anteriores. Por último, también se aplica a la implantación de nuevas funcionalidades de una misma aplicación, para que cada vez cumpla mejor la labor para la que haya sido desarrollada. En conjunto, supone una parte fundamental y necesaria para la aplicación. Cuando la actualización no se realiza con cierta periodicidad la aplicación acaba sufriendo pequeños errores o errores críticos. Cuanto más largo sea el periodo entre una actualización y la siguiente más complicado será conseguir que todo lo que se haya ido cambiando o mejorando sea aplicado de manera fácil.


