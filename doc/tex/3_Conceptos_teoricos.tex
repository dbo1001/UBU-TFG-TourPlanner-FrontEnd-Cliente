\capitulo{3}{Conceptos teóricos}

En este apartado se describirán ciertos conceptos teóricos que resultan necesarios para la correcta comprensión del proyecto.

\section{Modelo Cliente-Servidor}

Una parte importante de este proyecto es el concepto del modelo cliente-servidor, ya que cumple con la estructura que estamos utilizando. En este modelo y en el proyecto hay unas caracteristicas principales y unos actores concretos que son los siguientes:

\subsection{Cliente}
\begin{itemize}
\item Este se encarga de lanzar solicitudes o peticiones al servidor. Si lo comparamos con el proyecto de TourPlanner, podemos ver que la parte del cliente correspondería a la aplicación de Android.

\item El cliente es capaz de lanzar peticiones a diferentes servidores, como es nuestro caso en el que lanza peticiones tanto al servidor de OpenStreetMaps para poder visualizar el mapa online, a la base de datos que desarrolla mi compañero(lanza la petición a través de Glassfish) o por ejemplo a un servidor que provee las imágenes de los puntos de interés.

\item Obviamente este cliente contiene la interfaz que utilizará el usuario final, por lo que la interacción es directa.
\end{itemize}

\subsection{Servidor}
\begin{itemize}
\item El servidor es la otra parte indispensable de este modelo, ya que en el momento en que esta iniciado se encarga de escuchar a la espera de peticiones del cliente.

\item Al igual que un cliente puede realizar distintas peticiones a distintos servidores, el servidor puede mantener conexión con un gran numero de clientes y procesar las peticiones. 

\item Para este proyecto, quien cumple la funcion de servidor es GlassFish, que es a su vez un intermediario entre la aplicacion de android y la base de datos.
\end{itemize}

El proceso básico que también se verá en detalle mas adelante es el siguiente: el usuario interactua directamente con la aplicación (cliente), la cual realiza la petición a GlassFish (servidor), que a su vez realiza la petición a la base de datos y se la devuelve al cliente.

Al estar usando este modelo conseguimos una serie de ventajas:
\begin{itemize}
\item Centralización: Al contar con un servidor que recibe todas las peticiones que le lance el cliente, conseguimos un control de todos los accesos que se realizan y los recursos que se utilizan, pudiendo restringir o aumentar donde sea necesario.
\item Es un sistema muy fácilmente escalable, pudiendo aumentar las capacidades tanto de un lado como del otro independientemente, sin que al otro le afecte, o en todo caso teniendo que hacer modificaciones mínimas para que sea funcional. Esto mismo se traduce igualmente a la facilidad de mantenimiento, por las mismas razones.
\item Teniendo cierta relación con la primera ventaja, conseguimos seguridad, ya que actualmente contamos con tecnologías que permiten conexiones seguras entre cliente y servidor, y a su vez evitando posibles hackeos, ya que aunque varios clientes estén accediendo al mismo servidor, no pueden conocer las direcciones IP del resto. 
\end{itemize}

\section{Estándar}

Cuando se habla de estándar podemos considerar varias opciones, pero a la que nos referimos en este caso es el hecho de desarrollar software de un tipo especifico siguiendo ciertas reglas establecidas para así conseguir tener una cantidad indeterminada de programas y aplicaciones que contengan una estructura y una programación parecida, ya sea por el uso de los mismos métodos de una misma librería, o por seguir ciertos patrones con los que estructuras los programas de una manera concreta.

En el caso de Android, podemos considerar como estándar la librería en si que ofrece Android para programar, ya que todas las aplicaciones que están desarrolladas por Google para este tipo de dispositivos mantienen una estructura bastante parecida en el desarrollo de ciertas técnicas.

Una forma visual de demostrar esto se encuentra en el menú que utilizan la mayoría de aplicaciones, como el de Google Maps, Gmail o la aplicación para visualizar las fotos. Todos estos ejemplos utilizan una estructura prácticamente idéntica, y con esto se consigue lo que se llama estandarización, lo cual será explicado en el apartado de técnicas y herramientas.

\section{Code Smell}

Cuando se habla de Code Smell se esta hablando de problemas que puede contener el codigo de un programa, que no causa un error a la hora de ejecutar o compilar el programa, pero es un problema de caracter mas profundo, que acarrea otra serie de fallos, como puede ser la lentitud en un programa.

Estos problemas también dificultan el mantenimiento del código a futuro, ya que puede ser un error que en la actualidad no cause fallos, pero en el momento que se realicen modificaciones un programa que contenga estos Code Smells será mas propenso a fallos críticos, que, dependiendo del tipo de Code Smell que lo haya provocado, puede ser mucho mas difícil detectarlo en ese momento que cuando se cometió.

Gracias a la identificación de los Code Smells, se puede saber cuándo es necesario refactorizar código, que es una técnica que se explicará mas adelante. Con respecto a la identificación también es importante mencionar que tiene un carácter muy subjetivo, dependiendo del programador o incluso del lenguaje de programación, aunque existen herramientas que son capaces de detectar bastantes tipos de defecto, ya que algunos son mas subjetivos que otros (en el caso de código duplicado, aunque también pueden existir falsos negativos).

\section{API}

Una API, como su propio nombre indica, provee de una interfaz de programación de aplicaciones, en concreto, de una aplicación que será la que provee de esa API a otro software para que pueda hacer uso de rutinas, métodos y procedimientos con los cuales incluya la funcionalidad del software proveedor de la API.

Visto de otra forma, se basa en el uso de bibliotecas, y con esto se consigue que el programador no tenga que desarrollar todo el código que se encuentra en ellas, ya que con hacer uso de sus métodos y llamadas ya consigue esas funcionalidades.

Por otro lado, al hacer esto también se consigue estandarización, debido a que todos los programas que usen esas librerías para implementar sus funcionalidades estarán haciendo los mismos procesos de llamadas y usando los mismos métodos, así que se benefician de todas las ventajas con las que cuenta la estandarización, pero a su vez también corremos el riesgo de que esa estandarización se rompa, bien porque la API deje de dar soporte a la biblioteca que estamos utilizando, o porque en las nuevas versiones de una aplicación ya no sea compatible nuestra API implementada. 

Llevándolo a nuestro caso, tendríamos por un lado la API que nos permite visualizar imágenes de los puntos de interés, o por ejemplo la API con la que estamos viendo los mapas (OpenStreeMaps). Aquí se cumplen los dos casos referentes a la estandarización, con OpenStreetMaps conseguimos una API y un código válido y más sencillo, que se parecerá estructuralmente al de otros programadores y si necesitáramos soporte lo obtendríamos fácilmente, pero por el otro lado, tenemos la API de Panoramio que ya no es válida, dado que el servicio de esta página web dejó de estar disponible y por tanto nos veríamos obligados a buscar otra API que nos provea de las funcionalidades buscadas.

\section{Mantenimiento}

El concepto de mantenimiento en informática posee mucho valor, ya que el desarrollo de cualquier aplicación requiere mantenimiento posterior, y lo podemos dividir en dos aspectos:

\subsection{Soporte}

El soporte es una parte del mantenimiento, ya que después de cualquier desarrollo siempre habrá errores, bugs o fallos, y éstos pueden ser problemas que no afecten al funcionamiento normal de un aplicación o por el contrario que causen su parada total, quedando inutilizable. 

El soporte es un servicio a través del cual un especialista informático brinda asistencia, de forma física o remota a un individuo o una organización que hacen uso de la herramienta. En el caso de nuestra aplicación, el soporte del que hablamos sería remoto, a traves de una aplicación web o un foro, donde además de personas especializadas en esta aplicación, también hay otros usuarios que aportan su experiencia sobre ciertos problemas y en muchos casos estos problemas pueden ser resueltos sin necesidad de modificar el código, porque la falta de conocimiento del usuario es una de las mayores causas de incidencias que se suelen resolver en entornos de soporte.

\subsection{Actualización}

La otra parte importante del mantenimiento de una aplicación, sobre la que haremos mención en muchos aspectos de este trabajo es la actualización. 

Se basa en el cambio de código, APIs y librerías para obtener métodos nuevos, que están más optimizados para realizar la misma funcionalidad o también para solucionar errores que existieran en versiones anteriores. Por último, también se aplica a la implantación de nuevas funcionalidades de una misma aplicación, para que cada vez cumpa mejor la labor para la que haya sido desarrollada. En conjunto, supone una parte fundamental y necesaria para la aplicación. Cuando la actualización no se realiza con cierta periodicidad la aplicación acaba sufriendo pequeños errores o errores críticos. Cuanto más largo sea el periodo entre una actualización y la siguiente más complicado será conseguir que todo lo que se haya ido cambiando o mejorando sea aplicado de manera fácil.



\section{Referencias}

Las referencias se incluyen en el texto usando cite \cite{wiki:latex}. Para citar webs, artículos o libros \cite{koza92}.


\section{Imágenes}

Se pueden incluir imágenes con los comandos standard de \LaTeX, pero esta plantilla dispone de comandos propios como por ejemplo el siguiente:

\imagen{escudoInfor}{Autómata para una expresión vacía}



\section{Listas de items}

Existen tres posibilidades:

\begin{itemize}
	\item primer item.
	\item segundo item.
\end{itemize}

\begin{enumerate}
	\item primer item.
	\item segundo item.
\end{enumerate}

\begin{description}
	\item[Primer item] más información sobre el primer item.
	\item[Segundo item] más información sobre el segundo item.
\end{description}
	
\begin{itemize}
\item 
\end{itemize}

\section{Tablas}

Igualmente se pueden usar los comandos específicos de \LaTeX o bien usar alguno de los comandos de la plantilla.

\tablaSmall{Herramientas y tecnologías utilizadas en cada parte del proyecto}{l c c c c}{herramientasportipodeuso}
{ \multicolumn{1}{l}{Herramientas} & App AngularJS & API REST & BD & Memoria \\}{ 
HTML5 & X & & &\\
CSS3 & X & & &\\
BOOTSTRAP & X & & &\\
JavaScript & X & & &\\
AngularJS & X & & &\\
Bower & X & & &\\
PHP & & X & &\\
Karma + Jasmine & X & & &\\
Slim framework & & X & &\\
Idiorm & & X & &\\
Composer & & X & &\\
JSON & X & X & &\\
PhpStorm & X & X & &\\
MySQL & & & X &\\
PhpMyAdmin & & & X &\\
Git + BitBucket & X & X & X & X\\
Mik\TeX{} & & & & X\\
\TeX{}Maker & & & & X\\
Astah & & & & X\\
Balsamiq Mockups & X & & &\\
VersionOne & X & X & X & X\\
} 
